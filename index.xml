<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>首页 on Codist</title>
    <link>https://blog.codist.me/</link>
    <description>Recent content in 首页 on Codist</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 07 Apr 2019 18:48:52 +0800</lastBuildDate>
    
	<atom:link href="https://blog.codist.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>SET容器 - 自定义排序和去重</title>
      <link>https://blog.codist.me/stl/set/</link>
      <pubDate>Thu, 14 Mar 2019 16:32:45 +0800</pubDate>
      
      <guid>https://blog.codist.me/stl/set/</guid>
      <description>std::set，是基于红黑树的平衡二叉树的数据结构实现的一种容器，因为其中所包含的元素的值是唯一的，因此主要用于排序和去重。
1.使用内置的比较函数less 定义内置类型的set对象，限制：
 用于比较内置类型，如int，char 只能对一个内置类型进行排序或去重  示例排序(c++11)：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; int main() { std::set&amp;lt;int&amp;gt; testSet; testSet.insert(20); testSet.insert(10); for (auto i : testSet) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;; } std::cout &amp;lt;&amp;lt; std::endl; return 0; }  Microsoft Visual C++ 6.0(c++98)：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; int main() { std::set&amp;lt;int&amp;gt; testSet; testSet.insert(20); testSet.insert(10); //iteratorz，迭代器，用于遍历容器内元素和元素数据类型 for (set&amp;lt;int&amp;gt;::iterator i = testSet.begin(); i != testSet.end(); i++) { cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; &amp;quot; &amp;quot;; } cout &amp;lt;&amp;lt; endl; return 0; }  输出：</description>
    </item>
    
    <item>
      <title>Git 用GPG签名</title>
      <link>https://blog.codist.me/git/gpg/</link>
      <pubDate>Mon, 11 Mar 2019 20:03:50 +0800</pubDate>
      
      <guid>https://blog.codist.me/git/gpg/</guid>
      <description> 1. 生成GPG key gpg --full-generate-key   加密方式选择RSA and RSA 过期时间输入：4096 valid选择默认  填写信息后生成成功。
2.导出公钥 gpg --list-secret-keys --keyid-format LONG  rsa4096/后面的就是 GPG key ID
gpg --armor --export &amp;lt;要导出的GPG Key ID&amp;gt;  将得到的一大段公钥粘贴到git平台。
3.配置git 1.设置签名用的GPG key ID
git config --global user.signingkey &amp;lt;GPG Key ID&amp;gt;  2.设置gpg签名用的程序
git config --global gpg.program gpg  3.启用gpg签名
git config --global commit.gpgsign true  测试签名
echo &amp;quot;test&amp;quot; | gpg --clearsign  </description>
    </item>
    
    <item>
      <title>安装kaldi</title>
      <link>https://blog.codist.me/asr/kaldi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.codist.me/asr/kaldi/</guid>
      <description>环境 操作系统建议使用Ubuntu，因为官方源里已经有编译好的一些依赖库，如ATLAS，安装不会遇到太多问题。
需要安装有git，subversion，make以及gcc等编译工具链
1.下载源码 git clone https://github.com/kaldi-asr/kaldi.git  2.编译安装kaldi/tools 安装文档在kaldi/tools/INSTALL，很短，建议阅读一下
开始编译：
cd tools ./extras/check_dependencies.sh #检查依赖，如有问题参照仔细修改 #自动下载安装依赖 make -j 8  这会安装ATLAS headers, OpenFst, SCTK 和 sph2pipe
注意：如果要使用特定版本的编译器，必须和后面编译安装`kaldi/src`的编译器一致，如之后我们编译安装`cuda`要用`g++-7`，需要指定要用的编译器：  CXX=g++-7 extras/check_dependencies.sh make CXX=g++-7 -j 8  3.编译安装kaldi/src 3.1使用OpenBLAS 如果使用Ubuntu系统，源里有编译好的ATLAS库，可以直接安装，其他Linux发行版由于ATLAS安装复杂，需要调节cpu工作模式，这里用OpenBLAS替代：
cd tools ./extras/install_openblas.sh  3.2安装cuda thchs30和aishell的训练都需要用到cuda，建议在编译安装的时候就把相关依赖一并装好。
可以手动在nvidia官网下载cuda工具集，根据对应的显卡和平台：https://developer.nvidia.com/cuda-downloads ，再手动安装。
Archlinux可以直接从源里安装，Ubuntu等发行版类似：
sudo pacman -S cuda  注意：对于Archlinux，由于源里的cuda更新比较频繁，编译安装的kaldi会依赖指定版本的cuda，如果cuda大版本更新，如10.0=&amp;gt;10.1，会使kaldi找不到旧版的cuda库而出错，建议添加cuda到忽略升级里，或每次更新cuda后重新编译安装kaldi/src
3.3编译 根据安装文档下载编译依赖(这里使用OpenBLAS)，需要硬盘上有20G的空闲空间：
./configure --openblas-root=../tools/OpenBLAS/install  如果没有找到cuda安装路径，提示：
CUDA will not be used! If you have already installed cuda drivers and cuda toolkit, try using --cudatk-dir=.</description>
    </item>
    
    <item>
      <title>搭建博客评论系统</title>
      <link>https://blog.codist.me/selfhost/commento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.codist.me/selfhost/commento/</guid>
      <description>在Debian9上用开源的Commento搭建博客评论系统
安装 yarn：
curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo &amp;quot;deb https://dl.yarnpkg.com/debian/ stable main&amp;quot; | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install yarn  安装dep（需要已经配置好的go环境）：
go get -u github.com/golang/dep/cmd/dep export PATH=$PATH:$GOPATH/bin  下载&amp;amp;编译：
mkdir -p $GOPATH/gitlab.com/commento cd $GOPATH/gitlab.com/commento git clone https://gitlab.com/commento/commento.git make prod  在根目录下新建脚本server.sh：
#! /bin/bash # 绑定的域名 export COMMENTO_ORIGIN=https://comment.example.com # 绑定的端口，可以用nginx反向代理到这个端口 export COMMENTO_PORT=8002 # 数据库 PostgreSQL 设置 export COMMENTO_POSTGRES=postgres://postgres:password@127.0.0.1:5432/comment?sslmode=disable # 关闭注册，首次需要注册账号，之后可以关闭注册 #export COMMENTO_FORBID_NEW_OWNERS=true # # github oauth，其他类似 # export GITHUB_KEY= export GITHUB_SECRET= .</description>
    </item>
    
    <item>
      <title>使用thchs30数据集</title>
      <link>https://blog.codist.me/asr/thchs30/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.codist.me/asr/thchs30/</guid>
      <description>1.下载数据集 Kaldi中文语音识别公共数据集有：
 1.aishell：AI SHELL公司开源178小时中文语音语料及基本训练脚本，见kaldi-master/egs/aishell
 2.gale_mandarin：中文新闻广播数据集(LDC2013S08, LDC2013S08）
 3.hkust：中文电话数据集(LDC2005S15, LDC2005T32)
 4.thchs30：清华大学30小时的数据集，可以在http://www.openslr.org/18/ 下载
  这里采用thchs30，从http://www.openslr.org/18/ 或者参照它的README下载三个压缩包：
 data_thchs30.tgz 6.4G Mirrors: China
 test-noise.tgz 1.9G Mirrors: China
 resource.tgz 24M Mirrors: China
  在egs/thchs30/s5下新建文件夹thchs30-openslr，把三个文件解压在该文件夹下
这个数据集包含以下内容：
   数据集 音频时长(h) 句子数 词数     train(训练) 25 10000 198252   dev(开发) 2:14 893 17743   test(测试) 6:15 2495 49085    还有训练好的语言模型word.3gram.lm和phone.3gram.lm以及相应的词典lexicon.txt。
其中dev的作用是在某些步骤与train进行交叉验证的，如local/nnet/run_dnn.sh同时用到exp/tri4b_ali和exp/tri4b_ali_cv。训练和测试的目标数据也分为两类：word（词）和phone（音素）。</description>
    </item>
    
    <item>
      <title>使用aishell数据集</title>
      <link>https://blog.codist.me/asr/aishell/</link>
      <pubDate>Mon, 11 Mar 2019 19:19:26 +0800</pubDate>
      
      <guid>https://blog.codist.me/asr/aishell/</guid>
      <description>1.安装依赖 安装train_lm.sh：
cd tools ./extras/install_kaldi_lm.sh  2.获取数据集 和thchs30类似，参照egs/aishell/README.txt，手动下载数据集或运行s5/run.sh会自动下载并解压缩数据集，这里只演示手动下载数据集。
访问http://www.openslr.org/33/ ，下载两个压缩包：
data_aishell.tgz [15G] ( speech data and transcripts ) Mirrors: China
resource_aishell.tgz [1.2M] ( supplementary resources, incl. lexicon, speaker info ) Mirrors: China
下载解压缩到一个目录，这里解压缩到aishell-openslr
aishell-openslr/data_aishell/wav里的压缩包需要都解压出来，创建脚本local/untar.sh：
#!/bin/bash remove_archive=false if [ &amp;quot;$1&amp;quot; == --remove-archive ]; then remove_archive=true shift fi if [ $# -ne 3 ]; then echo &amp;quot;Usage: $0 &amp;lt;data-base&amp;gt;&amp;quot; echo &amp;quot;e.g.: $0 /export/a05/xna/data&amp;quot; fi data=$1 part=&amp;quot;data_aishell&amp;quot; if [ ! -d &amp;quot;$data&amp;quot; ]; then echo &amp;quot;$0: no such directory $data&amp;quot; exit 1; fi if [ -f $data/$part/.</description>
    </item>
    
    <item>
      <title>使用cvte预训练模型</title>
      <link>https://blog.codist.me/asr/cvte/</link>
      <pubDate>Sun, 07 Apr 2019 18:48:52 +0800</pubDate>
      
      <guid>https://blog.codist.me/asr/cvte/</guid>
      <description>cvte开放了已经训练好的模型，不用再花费大量时间和算力去训练，但注意cvte没有开源数据集和模型配置
获取模型 从 http://kaldi-asr.org/models/m2 下载 0002_cvte_chain_model.tar.gz(3.5G)
解压缩到kaldi/egs下，注意kaldi/egs/换成安装kaldi对应的目录：
tar -zxvf 0002_cvte_chain_model.tar.gz -C kaldi/egs/  解压生成目录kaldi/egs/cvte，按照cvte/README.txt链接steps，utils和score.sh，由于需要修改utils中的脚本，这里直接拷贝utils文件夹：
cd kaldi/egs/cvte/s5/ ln -s ../../wsj/s5/steps steps #ln -s ../../wsj/s5/utils utils cp -r ../../wsj/s5/utils utils cd local/ ln -s ../steps/score_kaldi.sh score.sh  修改解码脚本 修改utils/lang/check_phones_compatible.sh为：
# check if the files exist or not if [ ! -f $table_first ]; then if [ ! -f $table_second ]; then echo &amp;quot;$0: Error! Both of the two phones-symbol tables are absent.</description>
    </item>
    
    <item>
      <title>用minicom通过串口发送文件</title>
      <link>https://blog.codist.me/embedded/work6/</link>
      <pubDate>Wed, 26 Jul 2017 20:41:02 +0800</pubDate>
      
      <guid>https://blog.codist.me/embedded/work6/</guid>
      <description>1. 设置文件路径  设置需要传送的文件所在的路径
 按下组合键 Ctrl + A , 再按下 O
 选择 Filenames and paths：
    设置 A-Download directory （将文件从设备传送到本地的路径）
 设置 B-Upload directory （将文件从本地上传到设备的路径）向设备发送文件时，选择这个目录里的文件。
 按下 esc 然后选择 Save setup as dfl来保存设置：
  2. 发送文件到设备  在minicom里（已经连接到设备的终端）  rx filename   按下组合键 Ctrl + A，然后按下S 选择 xmodem 选择要发送的文件  3. 在设备上运行刚才发送过去的文件（假设是Qt图形界面程序） 在minicom里（已经连接到设备的终端）：
chmod +x filename #给文件授予执行权限 ./filename #运行  如果设备上的系统没有图形化环境 添加参数 -qws：</description>
    </item>
    
    <item>
      <title>Qt Creator 配置交叉编译</title>
      <link>https://blog.codist.me/embedded/work5/</link>
      <pubDate>Wed, 26 Jul 2017 09:11:37 +0800</pubDate>
      
      <guid>https://blog.codist.me/embedded/work5/</guid>
      <description>1. 获取对应的交叉编译工具链 假设目标平台的处理器是 imx28，则相应的工具链为 arm-fsl-linux-gnueabi</description>
    </item>
    
    <item>
      <title>Linux上通过串口连接嵌入式Linux终端</title>
      <link>https://blog.codist.me/embedded/work4/</link>
      <pubDate>Tue, 25 Jul 2017 09:38:52 +0800</pubDate>
      
      <guid>https://blog.codist.me/embedded/work4/</guid>
      <description>1. 安装 minicom Debian/Ubuntu：
sudo aptitude update sudo aptitude install minicom  2. 插上设备并查看系统是否已经检测到设备 sudo dmesg | grep tty  如果没有检测到设备，得到的结果类似： [ 0.000000] console [tty0] enabled [ 8.264501] systemd[1]: Created slice system-getty.slice.   拔下usb转串口线，输入命令 lsusb会看到一些已经连接到usb的设备：
Bus 002 Device 002: ID 8087:8000 Intel Corp. Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 001 Device 002: ID 8087:8008 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.</description>
    </item>
    
    <item>
      <title>Linux上摄像设备的使用</title>
      <link>https://blog.codist.me/linux/work3/</link>
      <pubDate>Thu, 20 Jul 2017 14:54:35 +0800</pubDate>
      
      <guid>https://blog.codist.me/linux/work3/</guid>
      <description>在Linux上配置网络摄像头，用到的一些软件，以及如何录制和播放设备的视频输入
1. 查找设备  插上摄像设备（通常是通过USB）
 列出所有的 video4linux 设备:
  ls -ltr /dev/video*   得到的输出类似于：  crw-rw----+ 1 root video 81, 0 Nov 11 09:06 /dev/video0  这里的摄像设备名称是 */dev/video0*，如果没有看到任何 /dev/video 文件，查看#排查问题。如果有多个 video4linux 设备，比如是一个tv card，摄像头设备应该显示为 /dev/video1 或类似的。但它的时间（在这个例子中是 Nov 11 09:06）应该是你插上它的时间。
2.测试设备  如果安装有 vlc，可以启动它，选择 Media -&amp;gt; Open Capture Device -&amp;gt; Video device name = /dev/video0 -&amp;gt; Play
 如果安装有mplayer，可以使用：
  mplayer tv:// -tv driver=v4l2:width=640:height=480:device=/dev/video0 -fps 30  3.</description>
    </item>
    
    <item>
      <title>Math Sample</title>
      <link>https://blog.codist.me/android/work8/</link>
      <pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://blog.codist.me/android/work8/</guid>
      <description>&lt;p&gt;KaTeX can be used to generate complex math formulas server-side.&lt;/p&gt;

&lt;p&gt;$$
\phi = \frac{(1+\sqrt{5})}{2} = 1.6180339887\cdots
$$&lt;/p&gt;

&lt;p&gt;Additional details can be found on &lt;a href=&#34;https://github.com/Khan/KaTeX&#34;&gt;GitHub&lt;/a&gt; or on the &lt;a href=&#34;http://tiddlywiki.com/plugins/tiddlywiki/katex/&#34;&gt;Wiki&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android&#39;s selinux</title>
      <link>https://blog.codist.me/android/work2/</link>
      <pubDate>Sat, 05 Nov 2016 19:41:01 +0530</pubDate>
      
      <guid>https://blog.codist.me/android/work2/</guid>
      <description>&lt;h2 id=&#34;一-适用情景&#34;&gt;一、适用情景&lt;/h2&gt;

&lt;p&gt;当在init.rc中新增service：&lt;/p&gt;

&lt;p&gt;service ro_isn /system/bin/isn.sh class late_start user root Oneshot&lt;/p&gt;

&lt;p&gt;kernel log会打印以下log：&lt;/p&gt;

&lt;p&gt;Warning! Service ro_isn needs a SELinux domain defined; please fix!&lt;/p&gt;

&lt;p&gt;这是因为Service ro_isn没有在SELinux的监控之下，这种情况会提示你定义一个SELinux。&lt;/p&gt;

&lt;p&gt;在这种情况下，你可以：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>将Android的系统日志输出到文件</title>
      <link>https://blog.codist.me/android/work1/</link>
      <pubDate>Sat, 11 Jun 2016 19:00:10 +0800</pubDate>
      
      <guid>https://blog.codist.me/android/work1/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>